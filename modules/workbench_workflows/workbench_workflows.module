<?php

/**
 * @file workbench_workflows.module
 */


// ---------------------------------------------------------------------------
// Database functions.


/**
 * Load a single workbench workflow.
 */
function workbench_workflows_load($name) {
  $cache = &drupal_static('workbench_workflows_load_all', array());

  // We use array_key_exists because failed loads will be NULL and
  // isset() will try to load it again.
  if (!array_key_exists($name, $cache)) {
    ctools_include('export');
    $result = ctools_export_load_object('workbench_moderation_exportables_workflows', 'names', array($name));
    if (isset($result[$name])) {
      $cache[$name] = $result[$name];
    }
    else {
      $cache[$name] = NULL;
    }
  }

  if (isset($cache[$name])) {
    return $cache[$name];
  }
}

/**
 * Load all workbench workflows.
 */
function workbench_workflows_load_all($reset = FALSE) {
  $cache = &drupal_static('workbench_workflows_load_all', array());
  static $all_loaded = FALSE;

  // We check our own private static because individual minis could have
  // been loaded prior to load all and we need to know that.
  if (!$all_loaded || $reset) {
    $all_loaded = TRUE;
    if ($reset) {
      $cache = array();
    }

    ctools_include('export');
    $workbench_workflows = ctools_export_load_object('workbench_moderation_exportables_workflows');
    uasort($workbench_workflows, 'ctools_plugin_sort');

    $cache = $workbench_workflows;
  }

  return $cache;
}

/**
 * Return the appropriate workflow for a node.
 */
function workbench_workflows_select_workflow($node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);


  $workflows = workbench_workflows_load_all();
  foreach($workflows as $workflow) {

    $contexts = ctools_context_match_required_contexts($workflow->requiredcontexts, array($node_context));
    $contexts = ctools_context_load_contexts($workflow, FALSE, $contexts);

    if (ctools_access($workflow->access, $contexts)) {
      // Return the first workflow for which ctools_access() returns TRUE.
      return $workflow;
    }
  }
  return FALSE;
}

/**
 * Implements hook_state_flow_plugins().
 */
function workbench_workflows_state_flow_plugins() {
  $info = array();

  // Load all workflows, events and states.
  $workflows = workbench_workflows_load_all();
  // @todo, workbench_events should have a helper function for this.
  $event_exportables = ctools_export_load_object('workbench_moderation_exportables_events');
  $state_exportables = workbench_states_load_all();

  // We're just building on top of the state_flow plugins.
  $class_path = drupal_get_path('module', 'state_flow') . '/plugins';

  foreach ($workflows as $workflow) {

    // This array will be built up and included with the state_flow plugin.
    $workflow_options = array();

    // Build up states in a way compatible with state_flow_plugins.
    foreach ($workflow->states as $state_name => $state) {
      $state_array = array(
        'label' => $state_exportables[$state_name]->admin_title,
      );

      // @todo, should there be a UI way of adding more of these?
      // Perhaps just a ui flag for "treat this as a published state."
      if ($state_name === 'published') {
        $state_array['on_enter'] = 'on_enter_published';
        $state_array['on_exit'] = 'on_exit_published';
      }

      $workflow_options['states'][$state_name] = $state_array;
    }

    // Build up events in a way compatible with state_flow_plugins.
    foreach ($workflow->events as $event_name => $event) {

      $origins = array();

      foreach($event_exportables[$event_name]->origin_states as $key => $state_value) {

        // $state_value might be 0.
        // This transformation is a little annoying. It might be better to fix
        // This in the validation of saving workbench_events.
        if (!empty($state_value)) {
          $origins[$key] = $state_value;
        }
      }

      $event_array = array(
        'origin' => $origins,
        'target' => $event_exportables[$event_name]->target_state,
        'guard' => 'workbench_workflows_guard',
        'label' => $event_exportables[$event_name]->admin_title,
      );

      $workflow_options['events'][$event_name] = $event_array;
    }

    $info['workbench_workflows__' . $workflow->name] = array(
      'handler' => array(
        // @todo, Once StateFlow can handle non-nodes, these properties will have
        // to respond to something in the $workflow variable to change the class
        // name and the file, parent etc.
        'class' => 'StateFlowNode',
        'file' => 'state_flow_node.inc',
        'path' => $class_path,
        'parent' => 'state_flow_entity',
        'workflow_options' => $workflow_options,
      ),
    );
  }

  return $info;
}

/**
 * Implements hook_state_flow_machine_type_alter()
 */
function workbench_workflows_state_flow_machine_type_alter(&$machine_type, $node) {

  $workflow = workbench_workflows_select_workflow($node);
  if (!empty($workflow->name)) {
    $machine_type = 'workbench_workflows__' . $workflow->name;
  }
}

/**
 * Guard callback for the workbenchStates publish and unpublish events.
 */
function workbench_workflows_guard($event) {
  return workbench_events_event_access($event->name, $event->get_machine()->get_object());
}
